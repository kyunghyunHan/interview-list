# 소유권

- Rust의 핵심
- 가비지 컬렉션과 다른 메모리가 컴파일타임에 컴파일러가 체크할 규칙들로 구성된 규칙들로 구성된 소유권 시스템을 통해 관리
- 소유권의 기능들의 어떤 것도 런타임 비용이 발생하지 않음

## 스택과 힙

- 코드상에서 런타임에 사용할 수 있는 메모리의 부분
- 스택은 값을 받아들인 순서대로 값을 저장 반대방향으로 값을 지웁니다 (last in ,first out)
- 접시를 쌓을때 밑에부터 접시를 뺼떄 위에부터
- 데이터를 추가하는 것을 스택에 푸시
- 데이터를 제거하는 것을 스택에 팝하기
- 스택은 데이터에 접근하는 방식 덕택에 빠릅니다
- 새로운 데이터를 넣어두기 위한 공간은 혹은 데이터를 가져올 공간을 검색할 필요가 전혀 없는데, 그공간이 바로 항상 스택의 꼭대기 이기 떄문
- 또한 스택에 담긴 모든 데이터가 결정되어 있는 고정된 크기를 갖고 있어야 하기떄문
- 힙은 컴파일 타임에 크기가 결정되어 있지 않거나 크기가 변경될수 있는 데이터
- 데이터를 힙에 넣을떄 먼저 저장할 공간이 있는지 그러면 운영채제가 충분히 커다란 힙 안의 빈 어떤 지점을 찾아서 이곳을 사용중이라고 표시
- 이절차를 힙공간 할당하기
- 힙에 저장된 데이터에 접근하는 것은 스택에 데이터에 접근하는 것보다 느린데 포인터가 가리킨 곳을 따라가야하기 때문

## 소유권 규칙

- 1. Rust의 각각의 값은 해당값의 오너라고 불리우는 변수를 갖고잇다
- 2. 한번에딱 하나의 오너만 존재
- 3. 너가 스코프 밖으로 벗어나는 떄 값은 버려진다

## 변수의 스코프

```rs
let s ="hello";
```

```rs
{                      // s는 유효하지 않습니다. 아직 선언이 안됐거든요.
    let s = "hello";   // s는 이 지점부터 유효합니다.

    // s를 가지고 뭔가 합니다.
}                      // 이 스코프는 이제 끝이므로, s는 더이상 유효하지 않습니다.
```

- 스코프 안에서 s 가 등장하면 유효
- 이 유효기간은 스코프 밖에서 벗어날때까지 지속

## string 타입

```rs
let s = String::from("hello");
```

- ::더블클론은 string_from같은 이름을 쓰기 보다는 String아래의 from함수를 특정 지욹수 있게 해주는 네임스페이스 연산자

```rs
let mut s= String::from("hello");
s.push_str(",world");//push_str()은 해당 스트링 리터럴을 스트링에 붙여줍니다.
printn!("{}",s);//hello출력
```

## 메모리와 할당

- string 리터럴에 내용물을 컴파일타임에 알수 있으므로 텍스트가 최종실행파일에 직접 하드코딩됬고, 이렇게 하면 string리터럴이 빠르고 효율적
- 그러나 문자열이 변경되지 않는 것을 전재로 하는 특성
- string타입은 변경 가능하고 커질수 있는 텍스트를 지원하기 위해 만들어졋고 힙에서 컴파일 타임에는 알수 없는 어느정도 크기의 메모리 공간을 할당 받아 내용물을 저장할 필요가 있습니다
- 1.런타임에 운영체제로부터 메모리가 요청되어야한다
- 2.string의 사용이 끝낫을떄 운영체제에게 메모리를 반납할 방법이 필요하다
- 첫번쨰는 직접수행 , sring::from 을 호출하면 구현부분에서 필요한 만큼의 메모리를 요청
- 두번쨰는 가비지콜렉터를 갖고있는 언어들의 경우 가비지컬렉턱 더이상 사용하지 않는 메모리 조각을 계속해서 찾고 지워주지만,없는 경우 할당받은 메모리가 더 필요 없는 시점을 알아서 명시적으로 이를 반납하는 코드를 호출하는것은 프로드래머 책임
- rust는 다른방식, 메모리는 변수가 소속되어 있는 스코프 밖으로 벗어나는 순간 자동으로 반납

```rs
{
    let s = String::from("hello"); // s는 여기서부터 유효합니다

    // s를 가지고 뭔가 합니다
}                                  // 이 스코프는 끝났고, s는 더 이상
                                   // 유효하지 않습니다

```

- rust는 괄호가 닫힐떄 자동으로 drop을 호출

## 변수와 데이터가 상호작용하는방법 move

```rs
let x = 5;
let y = x;
```

- 스트링버전

```rs
let s1 =String::from("hello");
let s2 = s1;
```

- string은 ptr,len,capacity로구성 이데이터 그룹은 스택에 저장
- 내용물은 힙 메모리에 저장 ptr->ptr[i].value
- s2에 s1을 대입하면 스택에 있는 포인터,길이값,그리고 용량값이 복사
- 포인터가 가리키고 있는 힙 메모리 상의 데이터는 복사되지 않는다
- shallow copy or deep copy

## 변수와 데이터 상호작용 하는 방법 :클론

- string의 스택 데이터 만이 아니라 힙데이터를 깊이 복사하기 원한다면 clone라는 mehods사용

```rs
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

## 스택에만 있는 데이터 복사

```rs
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

- clone를 호출하지는 않았지만 x도 유효 y호 이동하지도 않음
- 정수형과 같이 컴파일 타임에 결정되어 있는 타입은 스택에 모두 저장
- 러스트는 정수형과 스택에 저장할수 있는 타입에 대해 달수 있는 copy트레잇이라는 특별한 annotation 을 가지고 있다
- 카피가 가능한 타입들

```
u32와 같은 모든 정수형 타입들
true와 false값을 갖는 부울린 타입 bool
f64와 같은 모든 부동 소수점 타입들
Copy가 가능한 타입만으로 구성된 튜플들. (i32, i32)는 Copy가 되지만, (i32, String)은 안됩니다.
```

## 소유권과 함수

```rs
fn main() {
    let s = String::from("hello"); // s가 스코프 안으로 들어왔습니다.

    takes_ownership(s); // s의 값이 함수 안으로 이동했습니다...
                        // ... 그리고 이제 더이상 유효하지 않습니다.
    let x = 5; // x가 스코프 안으로 들어왔습니다.

    makes_copy(x); // x가 함수 안으로 이동했습니다만,
                   // i32는 Copy가 되므로, x를 이후에 계속
                   // 사용해도 됩니다.
} // 여기서 x는 스코프 밖으로 나가고, s도 그 후 나갑니다. 하지만 s는 이미 이동되었으므로,
  // 별다른 일이 발생하지 않습니다.

fn takes_ownership(some_string: String) {
    // some_string이 스코프 안으로 들어왔습니다.
    println!("{}", some_string);
} // 여기서 some_string이 스코프 밖으로 벗어났고 `drop`이 호출됩니다. 메모리는
  // 해제되었습니다.

fn makes_copy(some_integer: i32) {
    // some_integer이 스코프 안으로 들어왔습니다.
    println!("{}", some_integer);
} // 여기서 some_integer가 스코프 밖으로 벗어났습니다. 별다른 일은 발생하지 않습니다.
```

## 반환값과 스코프

```rs
fn main() {
    let s1 = gives_ownership();         // gives_ownership은 반환값을 s1에게
                                        // 이동시킵니다.

    let s2 = String::from("hello");     // s2가 스코프 안에 들어왔습니다.

    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back 안으로
                                        // 이동되었고, 이 함수가 반환값을 s3으로도
                                        // 이동시켰습니다.

} // 여기서 s3는 스코프 밖으로 벗어났으며 drop이 호출됩니다. s2는 스코프 밖으로
  // 벗어났지만 이동되었으므로 아무 일도 일어나지 않습니다. s1은 스코프 밖으로
  // 벗어나서 drop이 호출됩니다.

fn gives_ownership() -> String {             // gives_ownership 함수가 반환 값을
                                             // 호출한 쪽으로 이동시킵니다.

    let some_string = String::from("hello"); // some_string이 스코프 안에 들어왔습니다.

    some_string                              // some_string이 반환되고, 호출한 쪽의
                                             // 함수로 이동됩니다.
}

// takes_and_gives_back 함수는 String을 하나 받아서 다른 하나를 반환합니다.
fn takes_and_gives_back(a_string: String) -> String { // a_string이 스코프
                                                      // 안으로 들어왔습니다.

    a_string  // a_string은 반환되고, 호출한 쪽의 함수로 이동됩니다.
}
```

- 힙에 데이터를 갖는 변수가 스코프 밖으로 벗어나면 해당값은 데이터가 다른 변수에 의해 소유되도록 이동하지 않는 한 drop에 의해 제거
- 튜플을 이용 여러값을 돌려받는식

```rs
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len()함수는 문자열의 길이를 반환합니다.

    (s, length)
}
```
