# 난수 생성하기

- 다음으로 수행할 작업은 사용자가 예측해야할 난수를 생성하는것이다.
- rust는 이런 rand crate 를 제공한다

## 크레이트를 이용해 필요한 기능 추가

- 크레이트는 소스 파일의 집합
- 프로젝트 진행중인 프로젝트로 실행이 가능한 바이너리 크레이트 이다.
- rand크레이트 또한 라이브러리 크레이트 이며 다른 프로그램에서 재사용할 것을 염두에 두고 작성된 코드를 포함되고 있다.
- cargo.toml파일을 수정해서 rand크레이트를 의존 패키지로 등록해주어야 한다.
- Cargo.toml

```
[depedencies]
rand = "0.6.1"
```

- cargo.toml파일 내에서 헤더 다음에 작성하는 내용들은 다른 섹션의 헤더를 만나기 전까지는 해당 섹션에 속한다.
- [depedencies] 섹션에는 프로그램에 필요한 외부 크레이트의 종류와 버전을 카고에게 알려준다

```
cargo build
```

- 사용하는 시기에 따라 버전 번호가 다를수도 있으며 출력의 결과의 순서도 다를수 있다.
- 프로그램에 외부 의존 패키지를 추가하면 cargo는 패키지가 등록된 저장소에서 가장 최신의 복사본을 내려받는다
- 패키지 저장소의 업데이트가 끝나면 cargo는 [depedencies] 섹션을 완료하고 아직 다운로드되지 않은 크레이트를 다운로드 한다.
- cargo는 src/main.rs의 변경사항만을 빌드한다.

## cargo.lock파일을 이용해 재생산 가능 빌드 구현

- cargo는 다른 누군가가 이 코드를 빌드 하더라도 매번 같은 결과물을 재생산 하기위한 메커니즘이 있다.
- cargo는 무조건 명시된 버전의 의존 패키지만을 사용한다.
- rand패키지의 중요한 버그를 수정하였지만 그로 인해 코드가 컴파일 되지 않는 0.6.2버전이 출시된다면 어떻게 될가
- cargo.lock파일은 cargo build명령을 실행할떄 생성되며 디렉토리에 생성되었다.
- cargo는 프로젝트를 처음 빌드할떄 모든 의존 패키지를 검색 cargo.lock파일에 기록한다 그 다음부터 cargo.lock파일을 조회하고 이전 기록들을 사용한다.
- 명시적으로 업데이트 하지 않는 이상 계속해서 rand 0.6.1버전을 사용할 것이다.

## 새 버전의 크레이트로 업데이트

- cargo는 update라는 명령으로 크레이트를 업데이트 할수 있게 지원한다.
- 이 명령은 cargo.lock파일에 명시된 버전을 무시하고 cargo.toml파일에 지정된 가장 최신 버전을 다시 찾는다.

```
cargo update
```

## 난수 생성하기

```rs
use std::io;
use rand::Rng;

fn main(){
    println!("숫자를 맞혀 봅시다");
    let secrect_number=rand::thread_rng().gen_range(1,101);
    println!("사용자가 맞혀야 할 숫자:{}",secrect_number);
     println!("정답이라고 생각하는 숫자를 입력하세요");
     let mut guess = String::new();
     io::stdin().read_line(&mut guess).expect("입력한 값을 읽지 못했습니다.");
     println!("입력한 값:{}",guess);
}
```
