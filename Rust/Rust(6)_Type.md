# 데이터 타입

- rust에서는 모든 값은 어떤 타입의 데이터 이다.
- rust는 정적 타입 언어이다.즉 컴파일 시점에 모든 변수의 타입이 결정되어야한다.컴파일러는 타입 추론을 통해 변수에 할당된 값이나변수의 사용을 보고 실제 타입을 예측한다.

```rs
let guess:u32 = "42".parse().expect()("Not a number!");
```

- 타입을 명시해주지 않으면 러스트는 어떤 타입을 사용할 것인가에 더 많은 정보가 필요하다는 에러를 표시한다.

## 스칼라 타입

- sclar는 하나의 값으로 표현되는 타입
- Rust는 정수형,부동소수점 숫자 ,boolean,그리고 문자 네가지 스칼라 타입을 정의하고 있다

## 정수형

- 소주점이 없는 숫자다
- RUST는 기본 i32 , u32

|------|-------|--------|
|Length |Signed |Unsigned|
|8-bit |i8 |u8|
|16-bit| i16| u16|
|32-bit |i32| u32|
|64-bit| i64 |u64|
|arch |isize |usize|

- 각 타입은 부호가 있거나 앖으며 명시적인 크기가 정해져 있다.부호가 없고 있고의 차이는 음수인지 양수만 저장할수 있는지 결정한다.
- 부호가 잇는 타입은 할당되는 값이 음수나 양수일수 있으므로 이를 구분하기 위해 부호가 필요하다.
- 그러나 부호가 없는 타입은 무조건 양수이므로 부호가 필요없다.

- 정수형 리터럴들
  |------|-------|

|Number literals| Example|
|Decimal| 98_222|
|Hex |0xff|
|Octal |0o77|
|Binary |0b1111_0000|
|Byte (u8 only)| b'A'|

## 부동소수점 타입

- rust는 소수점을가진 숫자를 처리하기 위해 두개의 부동 소수점을 제공한다.
- f32와 f64 각각 32bit와 64bit크기다.
- rust는 기본 f64를 기본 타입으로 규정하고 있다.

```rs
fn main(){
    let x = 2.0;//f64
    let y :f32 = 3.0;//f32
}
```

- f32타입은 1배수의 정밀도인 부동소주점
- f64는 2배수의 정밀도인 부동소수점

## 수학적 연산

```rs
fn main(){
let sum = 5+10;
let difference = 95-4.3;
let profuct = 4*30;
let qeotient = 56.7/32.2;
let reminder = 43%5;

}
```

## Boolean타입

- true and false

```rs
fn main(){
    let t = true;
    let f:bool= false;
}
```

## 문자타입

- Rust의 char은 4byte크기의 유니코드 스칼라 값이므로 ASCII보다 더 많은 문자를 표현할수 있다.
- string이 ""를 쓰는것에 반하여 char은 ''사용
- rust의 char type은 unicode Scalar을 표현하는 값
- 한국어/중국어/일본어 표의 문자 이모티콘 모두 char로 가능

```rs
fn main() {
   let c = 'z';
   let z = 'ℤ';
   let heart_eyed_cat = '😻';
}
```

## 컴파운드 타입

- 컴파운드 타입은 하나의 타입으로 여러개의 값을 그룹화한 타입이다.rust는 기본적으로 튜플과 배열을 지원한다.
- 값들을 집핪시켜서 튜플화

## 튜플

- 튜플은 서로 다른 타입의 여러 값을 하나의 컴파운드 타이븡로 그룹화 하기에 적합한 타입이다.
- 튜플은 고정된 길이를 가지며 한번 정의하면 그 크기를 키우거나 줄일수 없다.튜플을 생성할 떄는 괄호 안에 갑의 목록을 쉼표로 구분해서 표기하면된다.
- 튜플의 각 요소는 타입을 가지며 반드시 같을 필요는 없다.

```rs
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

- 튜플은 하나의 컴파운드 요소로 인식되므로 이코드에서 선언한 변수 tup는 전체 튜플을 보관할수 있다.

```rs
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}

```

- 이 코드는 우선 튜플을 생성해 변수 tup에 할당한다.
- 그런 다음 let 구문에 패턴을 지정해 tup변수에 지정된 값을 x,y,z등 세개의 개별 변수에 각각 대입한다.
- 패턴 매칭을 이용한 해제 외에도 마침표 다음에 요소의 인데스를 지정해서 튜플에 각 요소를 직접 참조할수 있다.

```rs
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

- 다른 언어와 마친가지로 첫번쨰 인덱스는 0부터 시작한다

## 배열

- 여러값의 컬렉션을 활용하기 위해 또 다른 방법은 배열을 사용하는 것이다.
- 튜플과 달리 배열의 각 요소는 반드시 타입이 같아야한다.

```rs
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

- 배열은 다루고자 하는 데이터를 힙 이 아닌 스택에 메모리를 할당하거나 항상 고정된 개수의 요소들을 다룰떄 유용한다.
- 하지만 배열은 vector보다 유연하지는 않다.백터는 표준 라이브러리가 지원하며 배열과 유사하지만 크기를 자유롭게 조정할수 있다.

````rs

let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
              ```
````

- 배열 타입은 대괄호를 히용해 작성하며,괄호 안에는 각 원소의 타입과 세미클론 그리고 배열에 저장할 원소의 개수를 다음처럼 지정한다.

```rs
let a:[i32;5]=[1,2,3,4,5];
```

- i32는 각 원소의 타입이며 숫자 5는 배열의 길이이다.
- 배열타입의 선언은 배열을 초기화 하는 문법과 유사해보인다.각 원소에 같은 값으 가진 배열을 선언할 떄는 다음과 같이 초깃값과 세이클론 배열의 길이를 대괄호 안에 작성하면 된다.

```rs
let a = [3;5]
```

- 이 변수 a는 5개의 원소를가지며 모두 3이라는 값이 대입된다.

## 배열에 접근

- 배열은 스택에 할당된 한 덩어리의 메모리다.

```rs
fn main(){
let a = [1,2,3,4,5];
let first = a[0];
let second = a[1];

}

```

- 배열의 index[0]은 배열 내의 첫번쨰 요소를 가리키므로 first변수에는 1이 할당된다.
- 배열의 마지막 요소보다 큰 인덱스의 요솟값을 읽으려고 하면 에러가발생한다.

```rs
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```

```
cargo run
//error
```

- 컴파일 시점에는 아무런 에러를 발생하지 않지만 프로그램을 실행하면 런타임 에러가 발생한다.
- 인덱스가 배열의 길이보다 크게되면 패닉이 발생하기 떄문이다.
