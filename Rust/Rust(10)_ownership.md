# 소유권

- 소유권은 Rust의 핵심 기능이다.
- 모든 프로그램은 실행중인 동안에는 컴퓨터의 메모리를 관리해야한다.
- 어떤 언어는 가비지 콜렉터를 이용해 더이상 사용되지 않는 메모리를 지속적으로 찾아 자동으로 해제한다.
- rust는 컴파일러가 컴파일 시점에 검사하는 다양한 규칙으로 이루어진 소유권 시스템에 의해 관리된다.

## 스택메모리와 힙 메모리

- 대부분 프로그래밍 언어에서는 스택 메모리와 힙 메모리를 자주 신경 쓸 필요가 없다.
- 하지만 Rust에서는 값이 스택메모리에 저장되었는지 힙 메모리에 저장되었는지에 따라 언어의 동작이나 의사 결정에 큰 영향을 미친다.
- 스택과 힙은 모두 코드가 런타임에 활용하는 메모리의 일부이며 각자 다른 방법으로 데이터를 구상한다.
- 스택은 유입된 순서대로 데이터를 저장하며데이터를 읽을떄는 그 반대 순서로 읽는다.그래서 마지막에 들어온 값을 먼저 읽는다.
- 마치 그릇을 쌓아놓고 쓰는 방법과 유사하다.
- 스택에 새로운 데이터를 넣는 동적을 푸시라 하며 데이터를 꺼내는 동작을 팝 이라한다.
- 스택에 저장되는 모든 데이터는 고정된 크기를 가져야한다.
- 컴파일 시점에 크기를 알수 없는 데이터나 런타임에 동적으로 크기가 변하는 데이터는 힙 메모리에 저장한다.
- 힙은 스택에 비하면 조금 더 복잡하다.
- 힙에 데이터를 넣는 동작은 메모리의 일정 공간을 할애할 것을 요청하는 것이다.
- 따라서 운영체제는 힙 메모리에서 일정한 공간을 찾아 사용중인 메모르로 표시한후 해당 메모리의 주솟값인 포인터를 넘겨준다.
- 이 과정을 힙 메모리 할당또는 할당 이라 칭한다.
- 스택에 값을 푸시하는 동작에는 할당이 발생하지 않는다.포인터는 이미 크기가 고정된 값이므로 포인터는 스택에 저장할수 있지만 실제 포인터가 가리키는 데이터가 필요할떄 포인터가 가리키는 메모리를 따라 가야한다.
- 포인터를 따라 가는 것은 레스토랑에 입장하며 일행이 몇명인지 말해주면 직원이 빈테이블을찾아 안내해주는 것과 비슷하다.
- 스택에 데이터를 푸시하는 것이 힙에 할당하는 것보다 빠른 이유는 운영체제가 새데이터를 저장할 공간을 찾을 필요가 없기 떄문이다.
- 새 데이터는 항상 스택 가장 위에 추가된다.
- 힙에 공간을 할당하는 것은 상대적으로 더 많은 작업이 필요하다.
- 힙 메모리에 저장된 데이터에 대한 접근은 스택에 저장된 데이터에 접근하는 것보다 느리다.그 이유는 포인터를 따라 가야하기 떄문이다.
- 프로세스 역시 멀리 떨어진 데이터를 처리할떄보다 다른 데이터에 가까운데이터를 처리할때 더 능률적으로 동작한다.
- 코드에서 함수를 로출할떄 이 함수에는 힙메모리에 저장된 데이터에 대한 포인터를 포함한 여러 값이 전달되며 이 값들은 함수의 로컬 변수에 할당되어 스택에 저장된다.
- 함수 실행이 완료되면 이 값들은 스택에서 제거된다.
- 코드 어느 부분이 힙 메모리에 저장된 데이터를 사용하는지 추적하고 힙에 저장되는 데이터의 중복을 최소화해 사용하지 않는 데이터를 힙 메모리에서 제거하면 메모리 부족 문제를 제거할수 있다.

## 소유권 규칙

- 1. Rust의 각각의 값은 해당값의 오너라고 불리우는 변수를 갖고잇다
- 2. 한번에딱 하나의 오너만 존재
- 3. 너가 스코프 밖으로 벗어나는 떄 값은 버려진다

## 변수의 범위

```rs
let s ="hello";
```

```rs
{                      // s는 유효하지 않습니다. 아직 선언이 안됐거든요.
    let s = "hello";   // s는 이 지점부터 유효합니다.

    // s를 가지고 뭔가 합니다.
}                      // 이 스코프는 이제 끝이므로, s는 더이상 유효하지 않습니다.
```

- 변수s가 범위 안으로 들어오면 유효하다
- 변수는 범위를 벗어나기 전까지 유요하다.

## Sting타입

- 문자열은 불변이다.

```rs
let s =String::from("hello");
```

- 두개의 클론은 from함수를 String타입의 이름 공간으로 제한해서 string_from같은 이름대신 명료한 이름을 사용하기 위해서이다.

```rs
let mut s = String::from("hello");
s.push_str(",world"); //push_str()은 String인스턴스에 리터럴을 결합한다.
println!("{}",s);

```

## 메모리 할당

- 문자열 리터럴은 컴파일 시점에 문자열의 내용을 이미 알고 있으므로 텍스트를 최종 실행할 수 있는 형태로 하드코딩할수 있다.
- 문자열 리터럴은 빠르고 효율적이다. 하지만 이런 장점은 문자열 리터럴이 불변이라는 사실에서 비롯된다.
- 컴파일시점에 그길이를 미리 알수 없거나 프로그램의 실행중에 길이가 변경되는 문자열은 그 문자열이 사용할 메모리를 바이너리 형태로 미리 변환할수 없다.
- 가변 문자열을 지원하는 String타입은 길이를 조절할수 있는 텍스트 이므로 컴파일 시점에 알수 없는 내용을 저장하기 위해 힙 메모리에 일정 부분의 메모리를 할당해야한다.

```
1.해당 메모리는 반드시 런타임에 운영체제에 요청해야한다.
2.String 타입의 사용이 완료된 이후에는 이 메모리를 운영체제에 다시 돌려줄 방법이 필요하다.
```

- 첫번쨰 절차는 개발자가 처리해야한다.String::from함수를 호출하면 이 함수가 필요한 메모리를 요청한다.
- 두번쨰 절차는 다르다.가비지 콜렉터를 사용하는 언어는GC가 더이상 사용하지 않는 메모리를 추적해 해제하므로 개발자가 이를 처리할 필요가 없다.
- 러스트는 메모리의 할당과 해제를 다른 방식으로 수행한다.즉 변수에 할당된 메모리른 변수가 소유한 범위를 벗어나는 순간 자동으로 해제한다.

```rs
{
    let s =String::from("hello")//변수s는 이 지점부터 유효
    //필요한 동적 수행
}//s는 유효하지 않다.
```

- 변수 s가 사용하는 메모리를 운영체제로 돌려주기에매우 적합한 지점이 있다.바로 변수 s가 범위를 벗어나는 지점이다.변수가 범위를 벗어나면 rust는 drop이라는 함수를 호출한다.
- drop함수는 string타입을 구현한 개발자가 메모리를 해제하는 코드를 작성해둔 함수다.

## 변수와 데이터가 상호 작용하는 방식:이동

```rs
let x =5;
let y = x;
```

- 이 코드가 값 5를 대입한 후 변수 x의 값은 복사본을 변수 y에 대입하는 코드라는 점을 알수 있다.
- 정수는 고정 크기의 단순한 값이기 떄문에 5라는 값두개가 스택에 저장된다.

```rs
let s1 = String::from("hello");
let s2 =s1;
```

- 이코드는 변수s1의 복사값을 만들어 변수s2에 대입하는 것으로 알겟지만 동작이 되지 않는다.
- String타입은 문자열 콘텐츠를 저장하고 있는 메모리에 대한 포인터,길이 ,그리고 용량 세분으로 구상된다.
- 이 데이터는 스택에 저장된다.
- 길이는 string타입의 콘텐츠가 어느 정도의 메모리를 사용중인지 바이트 단위로 표현한 값이며, 용량은 string타입이 운영체제로 부터 할당받은 총 메모리를 바이트로 표현한 값이다.
- 변수 s1을 s2에 대입하면 String타입의 데이터가 복사된다.포인터가 가리키는 힙 메모리의 실제 데이터가 아니라 문자열에 대한 포인터와 길이용량이 스택에 복사된다.
- s2 = s1 같은 코드를 실행하면 힙 메모리에 저장된 데이터의 크기가 큰 경우 런타임 성능이 크게 떨어질 것이다.
- 변수 s2와s1이 범위를 벗어나면 두 변수 모두가 같은 메모리를 해제 하려고 하기 떄문이다.
- 이 문제는 이중 해제 에러라고 한다.
- 러스트는 할당된 메모리를 복하라는 대신 변수 s1이 더이상 유효하지 않다고 판단 하기 떄문에 변수 s1이 범위를 벗어날떼 메모리를 해제할 필요가 없다.
- 실제로 변수 s2에 변수s1을 복사한 후 변수s1을 다시 참조하면 코드가 동작히자 않는다.

```rs
let s1 = String::from("hello");
let s2 = s1;

println!("s1 = {}, s2 = {}", s1, s2);
```

- 실제 데이터를 복사하지 않고 포인터와 길이 용량만을 복사하는 동작이 얕은 복사와 비슷하다 생각할 것이다.
- 러스트는 첫번쨰 변수를 무효화 해버리므로 이 동작은 얕은 복사가 아닌 이동이라고 불린다.

## 변수와 데이터가 상호작용하는 방식 :복제

- 만일 스택 데이터가 아니라 힙 메모리에 저장된 string메모리를 복사하기 원한다면 clone이라는 공통 메서드를 사용하면된다.

```rs
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

- clone메서드를 호출하믄 코드를 보면 이 메서드를 통해 어떤 추가 코드가 실행된다는 것을 알수있다.
- 이코드는 복사하는 메모리에 크기에 따라 무거운 작업이 될수도 있다.

## 스택 전용 데이터:복사

```rs
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

- clone함수를 호출하지 않앗음에도 x는 여전히 유효하면 변수 y로 이동하지 않앗다.
- 정수형 같은 타입은 컴파일 시점에 이미 그 크기를 알수 잇으며 온전히 스택에 저장되기 떄문에 실제 값을 복사해도 전혀 부담되지 않는다.
- 러스트는 스택에 저장되는 정수형 같은 타입에 적용할수 있는 copy트레이트라는 특별한 특성을 제공한다.
- copy트레이트가 적용된 타입의 일부

```
u32와 같은 모든 정수형 타입들
true와 false값을 갖는 부울린 타입 bool
f64와 같은 모든 부동 소수점 타입들
Copy가 가능한 타입만으로 구성된 튜플들. (i32, i32)는 Copy가 되지만, (i32, String)은 안됩니다.
```

## 소유권과 함수

```rs
fn main() {
    let s = String::from("hello"); // s가 스코프 안으로 들어왔습니다.

    takes_ownership(s); // s의 값이 함수 안으로 이동했습니다...
                        // ... 그리고 이제 더이상 유효하지 않습니다.
    let x = 5; // x가 스코프 안으로 들어왔습니다.

    makes_copy(x); // x가 함수 안으로 이동했습니다만,
                   // i32는 Copy가 되므로, x를 이후에 계속
                   // 사용해도 됩니다.
} // 여기서 x는 스코프 밖으로 나가고, s도 그 후 나갑니다. 하지만 s는 이미 이동되었으므로,
  // 별다른 일이 발생하지 않습니다.

fn takes_ownership(some_string: String) {
    // some_string이 스코프 안으로 들어왔습니다.
    println!("{}", some_string);
} // 여기서 some_string이 스코프 밖으로 벗어났고 `drop`이 호출됩니다. 메모리는
  // 해제되었습니다.

fn makes_copy(some_integer: i32) {
    // some_integer이 스코프 안으로 들어왔습니다.
    println!("{}", some_integer);
} // 여기서 some_integer가 스코프 밖으로 벗어났습니다. 별다른 일은 발생하지 않습니다.
```

- takes_ownership함수를 호출한 다음에 변수 s를 호출하려고 하면 러스트는 컴파일 에러를 리턴한다.

## 리턴값과 범위

```rs
fn main() {
    let s1 = gives_ownership();         // gives_ownership은 반환값을 s1에게
                                        // 이동시킵니다.

    let s2 = String::from("hello");     // s2가 스코프 안에 들어왔습니다.

    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back 안으로
                                        // 이동되었고, 이 함수가 반환값을 s3으로도
                                        // 이동시켰습니다.

} // 여기서 s3는 스코프 밖으로 벗어났으며 drop이 호출됩니다. s2는 스코프 밖으로
  // 벗어났지만 이동되었으므로 아무 일도 일어나지 않습니다. s1은 스코프 밖으로
  // 벗어나서 drop이 호출됩니다.

fn gives_ownership() -> String {             // gives_ownership 함수가 반환 값을
                                             // 호출한 쪽으로 이동시킵니다.

    let some_string = String::from("hello"); // some_string이 스코프 안에 들어왔습니다.

    some_string                              // some_string이 반환되고, 호출한 쪽의
                                             // 함수로 이동됩니다.
}

// takes_and_gives_back 함수는 String을 하나 받아서 다른 하나를 반환합니다.
fn takes_and_gives_back(a_string: String) -> String { // a_string이 스코프
                                                      // 안으로 들어왔습니다.

    a_string  // a_string은 반환되고, 호출한 쪽의 함수로 이동됩니다.
}
```

- 변수의소유권은 매번 같은 패턴을 따른다.
- 값을 다른 변수에 할당하면 소유권이 옮겨진 것이다.
- 힙 메모리에 저장된 변수의 데이터는 소유권이 다른 변수로 옮겨지지 않았다면 범위를 벗어날떄 drop함수에 의해 제거된다.

```rs
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len()함수는 문자열의 길이를 반환합니다.

    (s, length)
}
```

- 모든 함수가 소유권을 확보하고 다시 리턴하는 방식은 다소 거추장스럽다.
- 함수에 값을 전달할때 소유권은 이전하지 않고 싶다면 참조를 사용하면된다.
