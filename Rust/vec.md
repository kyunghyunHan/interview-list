## Vec

- 백터를 이용하면 하나 이상의 값을 데이터 구조에 담을수 있으며 모든 값은 메모리상에 연속으로 저장됩니다
- 백터는 같은 타입의 값만을 저장할수 있다.

## 백터생성

```rs
let v :Vec<i32>=Vec::new();

```

- 타입에 대한 애노테이션 사용
- 아직 값을 저장하지 않았으므로 어떤값들이 저장될지 미리 알수 없기 때문에
- rust는 백터에 일단 값을 추가하면 그 타입을 유추할 수 있다.
- 값을 포함하는 새로운 백터 생성

```rs
let v = vec![1,2,3];
```

- 초기값을 i32타입으로 값을 지정햇으므로 러스트는 변수 v의 타입 Vec<i32>라고 유추하며 따라서 타입 에노테이션을 추가할 필요가 없다.

## 백터 수정

- 백터를 생성하고 값을 추가하려면 push메서드 사용

```rs
let mut  v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

## 백터 해제

- 백터와 백터에 저장된 값들이 해제되는 위치

```rs
{
    let v = vec![1,2,3,4];
    //변수 v를 사용하는 코드를 여기에 작성한다
}// 변수 v가 범위를 벗어나면 drop메서드가 호출되어 메모리가 해제된다
```

## 백터로부터 값 읽기

- 인덱스 문법과 get문법을 이용해 벡터의 값 읽기

```rs
let v = vec![1,2,3,4];

let third:&i32= &v[2];
println!("세번째 원소:{}",thied);

match v.get(2){
    Some(third)=>println!("세번쨰 원소:{}",third),
    None=>println!("세번쨰 원소가 없습니다");
}
```

- 1.하나는 백터에서 값을 읽으려면 0부터 시작하는 인덱스를 사용한다는점이다.
- 세번쨰 값을 읽으려면 인덱스 값 2를 사용한다
- 백테에서 값을 읽을떄 사용하는 두가지 방법
- 1.&와 []을 이용하여 이떄는 저장된 값에 대한 참조를 리턴
- 2.get메서드를 이용 이떄는 Option<&T>타입 값 리턴

- 다섯개의 값을 저장한 백터에서 100번쨰 인덱스 값 읽으려고 할떄

```rs
let v = vec![1,2,3,4,5];
let does_not_exist =&v[100];
let does_not_exist = v.get(100)
```

- 이코드를 실행하면 []방식은 panic이발생
- get메서드에 백터의 크기를 벗어나는 인덱스를 전달하는 방법은 패닉이 발생하지 않고 none값으 리턴
- 프로그램이 유요한 참조값을 얻게되면 벡터에 저장된 값에 대한 참조가 계속해서 유효할수 있도록 대여값 검사가 실행되어 소유권과 대여 규칙을 적용
- 값을 참조하는 변수를 생성한 상태에서 백터에 새로운 값 추가

```rs
let mut v = vec![1,2,3,4,5];
let first =  &v[0];
v.push(6)
//error 발생
```

- 얼핏보면 정상으로 동작해야 할것처럼 보인다.
- first에 저장된 첫번쨰 값에 대한 참조인데 왜 백터에 마지막 값에 값을 추가할수 없는것인가
- 현재 백터에 크기가 충분하지 않다면 백터에 마지막에 새로운 값을 추가하기 위해 새로운 메모리를 할당하고 이미저장된 값들을 새로운 메모리 공간으로 이동해야 할수 있기 떄문에
- 이떄 first변수에 저장된 참조는 메모리로 부터 해제

## 백터에 저장된 값을 순회하기

```rs
let v = vec![1,2,3,4,5];
for i in &v{
    println!("{}",i);
}
```

- 또한 가변 백터에 저장된 값에 대한 가변 참조를 얻어와 값을 변경할수도 있다

```rs

let mut v = vec![1,2,3,4,5];
for i in &mut v {
    *i +=50;
}
```

- 가변 참조가 가리키는 값을변경하려면 +=연산자를 사용하기 이전에 역참조 연선자 \*를 이용하여 변수 i 에 저장된 값을 가져와야한다

## 열거자를 이용해 여러 타입 저장하기

- 벡터는 오로지 같은 타입의 값만을 저장할수 있지만 열거자를 이용하면 여러타입을 저장할수 있다.

```rs
eum SpreadsheetCell{
    Int(i32),
    Float(f64),
    Text(String),


let row = vec![
    SpreadsheetCell::Int(3),
     SpreadsheetCell::Text(string::from("블루")),
      SpreadsheetCell::Float(10,12),
]}
```
